<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebSocket Multiple Image Display</title>
    <style>
      body {
        background-color: #fff;
      }

      #imageContainer {
        margin: 0;
        transform-origin: 0 0;
        background-color: #fff;
      }
      .typst-txt {
        pointer-events: bounding-box;
      }

      .tsel span,
      .tsel {
        position: fixed;
        text-align: justify;
        white-space: nowrap;
        width: 100%;
        height: 100%;
        text-align-last: justify;
        color: transparent;
      }
      .tsel span::-moz-selection,
      .tsel::-moz-selection {
        color: transpaent;
        background: #7db9dea0;
      }
      .tsel span::selection,
      .tsel::selection {
        color: transpaent;
        background: #7db9dea0;
      }
      svg {
        --glyph_fill: black;
      }
      .pseudo-link {
        fill: transparent;
        cursor: pointer;
        pointer-events: all;
      }
      .image_glyph image,
      .outline_glyph path {
        transform: matrix(1, 0, 0, 1, var(--o), 0);
      }
      .outline_glyph path {
        fill: var(--glyph_fill);
      }
      .hover .typst-txt {
        --glyph_fill: #66bab7;
      }
      .typst-txt:hover {
        --glyph_fill: #f75c2f;
      }
      .typst-jump-ripple,
      .typst-debug-react-ripple {
        width: 0;
        height: 0;
        background-color: transparent;
        position: absolute;
        border-radius: 50%;
      }
      .typst-jump-ripple {
        border: 1px solid #66bab7;
      }
      .typst-debug-react-ripple {
        border: 1px solid #cb1b45;
      }
      @keyframes typst-jump-ripple-effect {
        to {
          width: 10vw;
          height: 10vw;
          opacity: 0.01;
          margin: -5vw;
        }
      }
      @keyframes typst-debug-react-ripple-effect {
        to {
          width: 3vw;
          height: 3vw;
          opacity: 0.01;
          margin: -1.5vw;
        }
      }
    </style>
    <script>
      window.onload = function () {
        const imageContainer = document.getElementById("imageContainer");
        const svgContainer = document.createElement("div");
        let currentScale = 1; // variable for storing scaling factor
        let imageContainerWidth = imageContainer.offsetWidth;

        // drag (panal resizing) -> rescaling
        window.onresize = () => {
          const newImageContainerWidth = imageContainer.offsetWidth;
          currentScale =
            currentScale * (newImageContainerWidth / imageContainerWidth);
          imageContainerWidth = newImageContainerWidth;
          imageContainer.style.transformOrigin = "0px 0px";
          imageContainer.style.transform = `scale(${currentScale * 2})`;
        };

        // Ctrl+scroll rescaling
        // will disable auto resizing
        // fixed factors, same as pdf.js
        const factors = [
          0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7,
          1.9, 2.1, 2.4, 2.7, 3, 3.3, 3.7, 4.1, 4.6, 5.1, 5.7, 6.3, 7, 7.7, 8.5,
          9.4, 10,
        ];
        imageContainer.addEventListener("wheel", function (event) {
          if (event.ctrlKey) {
            event.preventDefault();

            if (window.onresize !== null) {
              // is auto resizing
              window.onresize = null;
            }

            // Get wheel scroll direction and calculate new scale
            if (event.deltaY < 0) {
              // enlarge
              if (currentScale >= factors.at(-1)) {
                // already large than max factor
                return;
              } else {
                currentScale = factors.filter((x) => x > currentScale).at(0);
              }
            } else if (event.deltaY > 0) {
              // reduce
              if (currentScale <= factors.at(0)) {
                return;
              } else {
                currentScale = factors.filter((x) => x < currentScale).at(-1);
              }
            } else {
              // no y-axis scroll
              return;
            }

            // Apply new scale
            imageContainer.style.transformOrigin = "0 0";
            imageContainer.style.transform = `scale(${currentScale * 2})`;
          }
        });

        let isFirstScale = true;
        let processStart;

        let socket;
        let socketOpen = false;

        function equal(prev, next) {
          if (prev.tagName === "g") {
            // compareAndReplaceRoot(prev, next);
            if (next.tagName === "g") {
              // data tid
              const prevDataTid = prev.getAttribute("data-tid");
              const nextDataTid = next.getAttribute("data-tid");
              if (prevDataTid && nextDataTid && prevDataTid === nextDataTid) {
                return true;
              }
            }
          }

          return false;
        }

        function replaceChildrenFineGranuality(prev, next) {
          for (let i = 0; i < prev.children.length; i++) {
            const prevChild = prev.children[i];
            const nextChild = next.children[i];
            console.log("replacing", prevChild, nextChild);
          }

          return false;
        }

        function replaceChildren(prev, next) {
          if (!replaceChildrenFineGranuality(prev, next)) {
            console.log("hard replace", prev, next);
            prev.replaceWith(next);
          }
        }

        function patchAndSucceed(prev, next) {
          console.log("patchAndSucceed", prev, next);
          if (equal(prev, next)) {
            return true;
          } else {
            next.removeAttribute("data-reuse-from");
            replaceChildren(prev, next);
            return false;
          }
        }

        function patchRoot(prev, next) {
          const availableOwnedResource = new Map();

          let styleCount = 0;
          for (let i = 0; i < prev.children.length; i++) {
            const prevChild = prev.children[i];
            const nextChild = next.children[i];
            if (prevChild.tagName === "defs") {
              console.log("prev defs", prevChild);
              console.log("next defs", nextChild);
              for (let j = 0; j < nextChild.children.length; j++) {
                const nextChildChild = nextChild.children[j];
                if (nextChildChild.tagName === 'g') {
                  const prevGlyphs = prevChild.querySelector('#glyph');
                  console.log("append glyphs:", nextChildChild.children, "to", prevGlyphs);
                  prevGlyphs.append(...nextChildChild.children);
                } else {
                  console.warn("clip path not handled", nextChildChild)
                }
              }
            } else if (prevChild.tagName === "style") {
              styleCount++;
              if (styleCount === 2) {
                // skip base style
                console.log("replace extra style");
                console.log("prev style", prevChild);
                console.log("next style", nextChild);
                prevChild.replaceWith(nextChild);
              }
            }
          }

          for (let i = 0; i < prev.children.length; i++) {
            const prevChild = prev.children[i];
            if (prevChild.tagName !== "g") {
              continue;
            }
            const data_tid = prevChild.getAttribute("data-tid");
            if (data_tid) {
              if (!availableOwnedResource.has(data_tid)) {
                availableOwnedResource.set(data_tid, [prevChild, []]);
              }
              availableOwnedResource.get(data_tid)[1].push(i);
            }
          }

          // console.log(availableOwnedResource);

          const targetView = [];

          const toPatch = [];

          for (let i = 0; i < next.children.length; i++) {
            const nextChild = next.children[i];
            if (nextChild.tagName !== "g") {
              continue;
            }

            const nextDataTid = nextChild.getAttribute("data-tid");
            if (!nextDataTid) {
              throw new Error(
                "not data tid for reusing g element for " + reuseTargetTid
              );
            }

            const reuseTargetTid = nextChild.getAttribute("data-reuse-from");
            if (!reuseTargetTid) {
              targetView.push(["append", nextChild]);
              continue;
            }
            if (!availableOwnedResource.has(reuseTargetTid)) {
              throw new Error(
                "no available resource for reuse " + reuseTargetTid
              );
            }

            const rsrc = availableOwnedResource.get(reuseTargetTid);
            const prevIdx = rsrc[1].pop();

            /// no available resource
            if (prevIdx === undefined) {
              targetView.push(["append", nextChild]);
              continue;
            }

            /// clean one is reused directly
            if (nextDataTid === reuseTargetTid) {
              targetView.push(["reuse", prevIdx]);
              continue;
            }

            /// dirty one should be patched and reused
            toPatch.push([prev.children[prevIdx], nextChild]);
            targetView.push(["reuse", prevIdx]);
          }

          for (let [prevChild, nextChild] of toPatch) {
            patchAndSucceed(prevChild, nextChild);
          }

          console.log("interpreted target view", targetView);

          const prevView = [];
          let j = 0;
          for (let fg = 0; fg < prev.children.length; fg++) {
            const prevChild = prev.children[fg];
            if (prevChild.tagName !== "g") {
              continue;
            }
            for (let off = fg; off < prev.children.length; off++) {
              const prevChild = prev.children[off];
              if (prevChild.tagName !== "g") {
                break;
              }
              while (j < targetView.length) {
                let done = false;
                switch (j) {
                  case "append":
                    prevView.push(["insert", off, nextChild]);
                    done = true;
                    break;
                  case "reuse":
                    const target_off = targetView[j][1];
                    if (target_off > off) {
                      prevView.push(["swap_in", off, target_off]);
                    } else if (target_off === off) {
                      done = true;
                    } else {
                      console.log(targetView, prevView, off, j);
                      throw new Error("reuse offset is less than prev offset");
                    }
                    break;
                }

                j++;
                if (done) {
                  break;
                }
              }
            }
            break;
          }

          console.log("interpreted previous view", prevView);
          for (const [op, off, fr] of prevView) {
            switch (op) {
              case "insert":
                prev.insertBefore(fr, prev.children[off]);
                break;
              case "swap_in":
                prev.insertBefore(prev.children[fr], prev.children[off]);
                break;
              default:
                throw new Error("unknown op " + op);
            }
          }
        }

        function setupSocket() {
          socket = new WebSocket("ws://127.0.0.1:23625");
          // socket.binaryType = "arraybuffer";
          socket.addEventListener("open", () => {
            socketOpen = true;
            console.log("WebSocket connection opened");
          });

          socket.addEventListener("close", () => {
            socketOpen = false;
            setTimeout(setupSocket, 1000);
          });

          // 当收到WebSocket数据时
          socket.addEventListener("message", (event) => {
            const data = event.data;
            const message_idx = data.indexOf(",");
            const message = [
              data.slice(0, message_idx),
              data.slice(message_idx + 1),
            ];
            console.log(message);

            let t0 = performance.now();
            let t1 = undefined;
            let t2 = undefined;
            switch (message[0]) {
              case "new":
                imageContainer.innerHTML = message[1];
                t1 = t2 = performance.now();
                break;
              case "diff-v0":
                const elem = document.createElement("div");
                elem.innerHTML = message[1];
                const svgElement = elem.firstElementChild;
                t1 = performance.now();
                patchRoot(imageContainer.firstElementChild, svgElement);
                t2 = performance.now();
                break;
              default:
                console.log("data", data);
                break;
            }

            console.log(
              `parse ${(t1 - t0).toFixed(2)} ms, replace ${(t2 - t1).toFixed(
                2
              )} ms, total ${(t2 - t0).toFixed(2)} ms`
            );
            const docRoot = imageContainer.firstElementChild;
            if (docRoot) {
              initTypstSvg(docRoot);
            }
          });

          // 当WebSocket连接关闭时
          socket.addEventListener("close", () => {
            console.log("WebSocket connection closed");
          });

          // 当发生错误时
          socket.addEventListener("error", (error) => {
            console.error("WebSocket Error: ", error);
          });
        }
        setupSocket();
      };

      // debounce https://stackoverflow.com/questions/23181243/throttling-a-mousemove-event-to-fire-no-more-than-5-times-a-second
      // ignore fast events, good for capturing double click
      // @param (callback): function to be run when done
      // @param (delay): integer in milliseconds
      // @param (id): string value of a unique event id
      // @doc (event.timeStamp): http://api.jquery.com/event.timeStamp/
      // @bug (event.currentTime): https://bugzilla.mozilla.org/show_bug.cgi?id=238041
      var ignoredEvent = (function () {
        var last = {},
          diff,
          time;

        return function (callback, delay, id) {
          time = new Date().getTime();
          id = id || "ignored event";
          diff = last[id] ? time - last[id] : time;

          if (diff > delay) {
            last[id] = time;
            callback();
          }
        };
      })();

      var overLapping = function (a, b) {
        var aRect = a.getBoundingClientRect();
        var bRect = b.getBoundingClientRect();

        return (
          !(
            aRect.right < bRect.left ||
            aRect.left > bRect.right ||
            aRect.bottom < bRect.top ||
            aRect.top > bRect.bottom
          ) &&
          /// determine overlapping by area
          (Math.abs(aRect.left - bRect.left) +
            Math.abs(aRect.right - bRect.right)) /
            Math.max(aRect.width, bRect.width) <
            0.5 &&
          (Math.abs(aRect.bottom - bRect.bottom) +
            Math.abs(aRect.top - bRect.top)) /
            Math.max(aRect.height, bRect.height) <
            0.5
        );
      };

      var searchIntersections = function (root) {
        let parent = undefined,
          current = root;
        while (current) {
          if (current.classList.contains("group")) {
            parent = current;
            break;
          }
          current = current.parentElement;
        }
        if (!current) {
          console.log("no group found");
          return;
        }
        const group = parent;
        const children = group.children;
        const childCount = children.length;

        const res = [];

        for (let i = 0; i < childCount; i++) {
          const child = children[i];
          if (!overLapping(child, root)) {
            continue;
          }
          res.push(child);
        }

        return res;
      };

      var getRelatedElements = function (event) {
        let relatedElements = event.target.relatedElements;
        if (relatedElements === undefined || relatedElements === null) {
          relatedElements = event.target.relatedElements = searchIntersections(
            event.target
          );
        }
        return relatedElements;
      };

      var linkmove = function (event) {
        ignoredEvent(
          function () {
            const elements = getRelatedElements(event);
            if (elements === undefined || elements === null) {
              return;
            }
            for (var i = 0; i < elements.length; i++) {
              var elem = elements[i];
              if (elem.classList.contains("hover")) {
                continue;
              }
              elem.classList.add("hover");
            }
          },
          200,
          "mouse-move"
        );
      };

      var linkleave = function (event) {
        const elements = getRelatedElements(event);
        if (elements === undefined || elements === null) {
          return;
        }
        for (var i = 0; i < elements.length; i++) {
          var elem = elements[i];
          if (!elem.classList.contains("hover")) {
            continue;
          }
          elem.classList.remove("hover");
        }
      };

      function findAncestor(el, cls) {
        while ((el = el.parentElement) && !el.classList.contains(cls));
        return el;
      }

      window.initTypstSvg = function (docRoot) {
        var elements = docRoot.getElementsByClassName("pseudo-link");

        for (var i = 0; i < elements.length; i++) {
          var elem = elements[i];
          elem.addEventListener("mousemove", linkmove);
          elem.addEventListener("mouseleave", linkleave);
        }

        if (false) {
          setTimeout(() => {
            window.layoutText(docRoot);
          }, 0);
        }

        docRoot.addEventListener("click", (event) => {
          let elem = event.target;
          while (elem) {
            const span = elem.getAttribute("data-span");
            if (span) {
              console.log("source-span of this svg element", span);

              const docRoot = document.body || document.firstElementChild;
              const basePos = docRoot.getBoundingClientRect();

              const vw = window.innerWidth || 0;
              const left = event.clientX - basePos.left + 0.015 * vw;
              const top = event.clientY - basePos.top + 0.015 * vw;

              triggerRipple(
                docRoot,
                left,
                top,
                "typst-debug-react-ripple",
                "typst-debug-react-ripple-effect .4s linear"
              );
              return;
            }
            elem = elem.parentElement;
          }
        });
      };

      window.layoutText = function (svg) {
        const divs = svg.querySelectorAll(".tsel");
        const ctx = document
          .createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          .getContext("2d");

        const layoutBegin = performance.now();

        for (let d of divs) {
          if (d.getAttribute("data-typst-layout-checked")) {
            continue;
          }

          if (d.style.fontSize) {
            const foreignObj = d.parentElement;
            const innerText = d.innerText;
            const targetWidth = Number.parseFloat(
              foreignObj.getAttribute("width")
            );
            const currentX =
              Number.parseFloat(foreignObj.getAttribute("x")) || 0;
            ctx.font = `${d.style.fontSize} sans-serif`;
            const selfWidth = ctx.measureText(innerText).width;

            const scale = targetWidth / selfWidth;

            d.style.transform = `scaleX(${scale})`;
            foreignObj.setAttribute("width", selfWidth);
            foreignObj.setAttribute(
              "x",
              currentX - (selfWidth - targetWidth) * 0.5
            );

            d.setAttribute("data-typst-layout-checked", "1");
          }
        }

        console.log(
          `layoutText used time ${performance.now() - layoutBegin} ms`
        );
      };

      window.handleTypstLocation = function (elem, page, x, y) {
        const docRoot = findAncestor(elem, "typst-doc");
        const children = docRoot.children;
        let nthPage = 0;
        for (let i = 0; i < children.length; i++) {
          if (children[i].tagName === "g") {
            nthPage++;
          }
          if (nthPage == page) {
            const page = children[i];
            const dataWidth = page.getAttribute("data-page-width");
            const dataHeight = page.getAttribute("data-page-height");
            const rect = page.getBoundingClientRect();
            const xOffsetInner = Math.max(0, x / dataWidth - 0.05) * rect.width;
            const yOffsetInner =
              Math.max(0, y / dataHeight - 0.05) * rect.height;
            const xOffsetInnerFix = (x / dataWidth) * rect.width - xOffsetInner;
            const yOffsetInnerFix =
              (y / dataHeight) * rect.height - yOffsetInner;

            const docRoot = document.body || document.firstElementChild;
            const basePos = docRoot.getBoundingClientRect();

            const xOffset = rect.left - basePos.left + xOffsetInner;
            const yOffset = rect.top - basePos.top + yOffsetInner;
            const left = xOffset + xOffsetInnerFix;
            const top = yOffset + yOffsetInnerFix;

            window.scrollTo(xOffset, yOffset);

            triggerRipple(
              docRoot,
              left,
              top,
              "typst-jump-ripple",
              "typst-jump-ripple-effect .4s linear"
            );
            return;
          }
        }
      };

      function triggerRipple(docRoot, left, top, className, animation) {
        const ripple = document.createElement("div");

        ripple.className = className;
        ripple.style.left = left.toString() + "px";
        ripple.style.top = top.toString() + "px";

        docRoot.appendChild(ripple);

        ripple.style.animation = animation;
        ripple.onanimationend = () => {
          docRoot.removeChild(ripple);
        };
      }
    </script>
  </head>

  <body style="padding: 0px 0px 0px 0px">
    <div id="imageContainer" style="height: 0px"></div>
  </body>
</html>
